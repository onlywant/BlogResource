---
title: C++新特性
date: 2022-02-19 12:24:37
tags:
    - C++
categories:
    - 语言
---

# C++新特性

## C++11
###  auto & decltype
可以在**编译阶段**推导出变量或者表达式的类型。
**auto：** 推导 变量类型。
`auto x = 1;`
**decltype：** 推导 表达式类型。
`decltype(x);`

### 左值 和 右值

**左值：** 可以取地址，有名字
**右值：** 不能取地址、没有名字
**纯右值：** 运算表达式产生的临时变量，非引用返回的临时变量，lambda表达式等。
**将亡值：** 将要销毁的值
**左值引用：**
**右值引用：**：
>右值引用出现之前, 右值的地址只能绑定到常量左值

**移动语义：** 
> 为了解决进行大数据复制的时候，进行大量的数据移动，记节省空间又提高效率。
> 转移资源所有权，类似于转让或者资源窃取，对于那个资源，转为自己所有，别人不再拥有也不会再使用。

**移动构造函数：**
> **std::move的本质**，就是一个转换函数，将给定的类型转化为右值引用，而并不是真正地“移动”了资源

> 如果同时提供了复制构造函数和移动构造函数(或运算符)，**则当实参为右值 (如临时变量或 std::move函数的结果) 时，将会调用移动构造函数**，**当实参为左值时，选择复制赋值**。若仅提供了复制赋值，则所有值类别时都选择它（只要它按值或按到 const 的引用接收其实参），这使得在移动不可用时，以复制赋值成为移动赋值的后备。
注: 如果在执行移动语义时, 涉及的数据中有指向堆内存的指针, 该指针交出数据的所有权，为了不出现析构两次同一内存区域，**要将交出所有权的数据的指向动态申请内存区的指针赋值为空指针**(如 nullptr)，而对空指针执行delete / delete[]是合法的

**完美转发：** 可以写一个接受任意实参的函数模板，并转发到其他函数，目标函数会受到与转发函数完全相同的实参

### 列表初始化
C++11中可以直接在变量名后加上初始化列表进行对象的初始化。

### lambda 表达式
对函数的封装发挥到了极致。

### 并发


### 智能指针
引入了智能指针的概念，方便管理堆内存，使得自动、异常安全的对象生存期管理可行。解决内存泄露问题，构造函数不能被隐式调用

**摒弃auto_ptr的原因**，一句话总结就是：避免潜在的内存崩溃问题。
1. **std::shared_ptr**：使用了引用计数，每一个shared_ptr的拷贝都指向相同的内存，每次拷贝都会触发引用计数+1，每次生命周期结束析构的时候引用计数-1，在最后一个shared_ptr析构的时候，内存才会释放。
2. std::weak_ptr
3. std::unique_ptr

### 范围for

### 委托构造函数


### nullptr
空指针引入的常量值。

### delete
delele函数在c++11中很常用，std::unique_ptr就是通过delete修饰来禁止对象的拷贝的

### constexpr
> **编译时的常量和常量函数**

> 与const区别：
两者都代表可读，const只表示read only的语义，只保证了运行时不可以被修改，但它修饰的仍然有可能是个动态变量，而constexpr修饰的才是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，**constexpr可以用于修饰函数，这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理。**
```c++
#include<iostream>
using namespace std;
constexpr int func(int i) {
   return i + 1;
}
int main() {
   int i = 2;
   func(i);// 普通函数
   func(2);// 编译期间就会被计算出来
}
```
