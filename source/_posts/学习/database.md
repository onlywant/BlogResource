---
title: 数据库相关
date: 2022-02-19 09:22:54
tags: 
	- 数据库
categories:
	- 后端
---


ORM

NoSQL

[LSM 树](https://zhuanlan.zhihu.com/p/181498475)

# 数据库复习
## 一、索引
数据库的目录。相当于字典上的字母目录。
**优点：** 查的快
**缺点：** 增删改慢，同步维护索引
**结构：** B+树
### 什么是聚簇索引
是一种存储方式，将数据存储和索引放到一起，找到索引就找到了数据。


## 二、事务
sql是先写日志，再写数据库。
如果没有提交，断电，自动回滚。
事务已经提交，断电，根据日志继续执行。
[参考](https://leetcode-cn.com/leetbook/read/database-handbook/px8dnd/)
### 日志
**Buffer Pool**：大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。
**redo log**：当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。
刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。

**binlog**：binlog是用于point-in-time recovery的，保证服务器可以基于时间点恢复数据，此外binlog还用于主从复制。binlog的内容是二进制的，根据binlog_format参数的不同，可能基于sql语句、基于数据本身或者二者的混合。

**undo log**：Undo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把逆操作记录到undo log 里，当事务进行回滚时可以通过undo log 里的日志进行数据还原。


**事务的状态**
	1. 活跃状态
	2. 部分提交状态
	3. 失败状态
	4. 终止状态
	5. 提交状态
### 四大特性
**原子性**：要么全部执行，要么全部不执行
**一致性**：账户余额处于一致状态
**隔离性**：各个事务不被其他事务干扰
**持久性**：事务被提交，对数据的改变是持久的，即使发生故障也不能有任何影响

## 三、锁
**悲观锁**：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。这对于长事务来讲，可能会严重影响系统的并发处理能力。实现方式：使用数据库中的锁机制。

**乐观锁**：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁适用于 读多写少 的应用场景，这样可以提高吞吐量。实现方式：一般会使用版本号机制或 CAS 算法实现。


## 二、优化
1.表设计是否规范，是否符合三范式的标准
（1）第一范式：保证原子性（不可拆分）
（2）第二范式：每张表都有主键
（3）第三范式（每一列都有主键相关)
2.查看数据表中是否存在大量的冗余字段，字段数据类型是否合理
3.尽可能的使用varchar代替char 建表数据类型，能用数值的绝对不用字符存储
4.尽量避免null值，使用默认值替代空值，数值型可以使用0，字符型可以使用空字符串


## MySQL 主从复制的工作原理
Master 端：打开二进制日志（binlog ）记录功能 —— 记录下所有改变了数据库数据的语句，放进 Master 的 binlog 中；

Slave 端：开启一个 I/O 线程 —— 负责从 Master上拉取 binlog 内容，放进自己的中继日志（Relay log）中；

Slave 端：SQL 执行线程 —— 读取 Relay log，并顺序执行该日志中的 SQL 事件。

## MySQL 读写分离的实现方案
在应用和数据库之间增加 代理层，代理层接收应用对数据库的请求，根据不同请求类型（即是读 read 还是写 write）转发到不同的实例
读发给从库，写发给主库
